// Generated by CoffeeScript 1.4.0
var __slice = [].slice;

define(function(require, exports) {
  var even;
  even = function(n) {
    return n % 2 === 0;
  };
  exports.codearea = function(area) {
    var at_line_end, at_line_sta, call_shortcut, get_col, get_row, key_backspace, key_bracket, key_bracket_close, key_ctrl_enter, key_ctrl_k, key_ctrl_l, key_ctrl_shift_d, key_ctrl_shift_down, key_ctrl_shift_enter, key_ctrl_shift_k, key_ctrl_shift_up, key_ctrl_u, key_enter, key_esc, key_home, key_quote, key_shift_tab, key_tab, o, set_position, wrap_text, write_text;
    o = function() {
      var v;
      v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return console.log(v);
    };
    wrap_text = function() {
      var ac, all, ar, contx, end, obj, sta;
      sta = area.selectionStart;
      end = area.selectionEnd;
      contx = area.value;
      all = contx.split('\n');
      ar = get_row(contx, sta);
      ac = get_col(contx, sta);
      return obj = {
        row: ar,
        col: ac,
        all: all,
        ar: ar,
        ac: ac,
        as: at_line_sta(contx, sta),
        ae: at_line_end(contx, sta),
        br: get_row(contx, end),
        bc: get_col(contx, end),
        bs: at_line_sta(contx, end),
        be: at_line_end(contx, end),
        same: sta === end
      };
    };
    write_text = function(obj) {
      var ac, ar, arr, bc, br, end_line;
      arr = obj.all.length > 0 ? obj.all : [''];
      end_line = arr.length - 1;
      ar = obj.ar != null ? obj.ar : end_line;
      ac = obj.ac != null ? obj.ac : arr[ar].length;
      br = obj.br != null ? obj.br : ar;
      if (obj.bc != null) {
        bc = obj.bc;
      } else {
        if (obj.br != null) {
          bc = arr[br].length;
        } else {
          bc = ac;
        }
      }
      area.value = arr.join('\n');
      area.selectionStart = set_position(arr, ar, ac);
      area.selectionEnd = set_position(arr, br, bc);
      return false;
    };
    set_position = function(arr, row, col) {
      var all_before_curse, inline_before_curse, position, text_before_curse;
      all_before_curse = arr.slice(0, row);
      inline_before_curse = arr[row] != null ? arr[row].slice(0, col) : '';
      all_before_curse.push(inline_before_curse);
      text_before_curse = all_before_curse.join('\n');
      return position = text_before_curse.length;
    };
    get_row = function(str, point) {
      var count, i, _i, _len;
      count = 0;
      str = str.slice(0, point);
      for (_i = 0, _len = str.length; _i < _len; _i++) {
        i = str[_i];
        if (i === '\n') {
          count += 1;
        }
      }
      return count;
    };
    get_col = function(str, point) {
      var last, n, sub_str;
      str = str.slice(0, point);
      last = str.lastIndexOf('\n');
      last += 1;
      sub_str = str.slice(last);
      return n = sub_str.length;
    };
    at_line_sta = function(text, point) {
      var p;
      p = point - 1;
      if (text[p] === '\n') {
        return true;
      }
      if (text[p] == null) {
        return true;
      }
      return false;
    };
    at_line_end = function(text, point) {
      var p;
      p = point;
      if (text[p] === '\n') {
        return true;
      }
      if (text[p] == null) {
        return true;
      }
      return false;
    };
    key_tab = function() {
      var ac, add_n, all, ar, bc, br, caret, index, space_n, spaces, _i;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
      if (caret.same) {
        if (caret.as && ar > 0 && all[ar - 1].match(/^\s+/)) {
          spaces = (all[ar - 1].match(/^\s+/))[0];
          all[ar] = spaces + all[ar];
          ac = spaces.length;
          return write_text({
            all: all,
            ar: ar,
            ac: ac
          });
        } else {
          spaces = (all[ar].match(/^\s*/))[0];
          space_n = spaces.length;
          add_n = 2 - space_n % 2;
          if (add_n === 1) {
            all[ar] = '\ ' + all[ar];
          } else {
            all[ar] = '\ \ ' + all[ar];
          }
          ac += add_n;
          return write_text({
            all: all,
            ar: ar,
            ac: ac
          });
        }
      } else {
        ar = caret.ar;
        br = caret.br;
        for (index = _i = ar; ar <= br ? _i <= br : _i >= br; index = ar <= br ? ++_i : --_i) {
          all[index] = '\ \ ' + all[index];
        }
        ac += 2;
        bc += 2;
        return write_text({
          all: all,
          ar: ar,
          ac: ac,
          br: br,
          bc: bc
        });
      }
    };
    key_shift_tab = function() {
      var ac, all, ar, bc, br, caret, index, min_spaces, obj, reduce_n, space_n, space_ns, spaces, _i;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
      if (caret.same) {
        ar = caret.ar;
        spaces = (all[ar].match(/^\s*/))[0];
        space_n = spaces.length;
        reduce_n = 2 - spaces % 2;
        if (space_n >= reduce_n) {
          all[ar] = all[ar].slice(reduce_n);
          obj = {
            all: all,
            ar: ar
          };
          ac = ac - reduce_n > 0 ? ac - reduce_n : 0;
          return write_text({
            all: all,
            ar: ar,
            ac: ac
          });
        }
      } else {
        space_ns = all.slice(ar, +br + 1 || 9e9).map(function(line) {
          spaces = (line.match(/^\s*/))[0];
          return spaces.length;
        });
        min_spaces = space_ns.reduce(function(a, b) {
          if (a < b) {
            return a;
          } else {
            return b;
          }
        });
        if (min_spaces > 0) {
          reduce_n = 2 - min_spaces % 2;
          for (index = _i = ar; ar <= br ? _i <= br : _i >= br; index = ar <= br ? ++_i : --_i) {
            all[index] = all[index].slice(reduce_n);
          }
          ac -= reduce_n;
          bc -= reduce_n;
          return write_text({
            all: all,
            ar: ar,
            ac: ac,
            br: br,
            bc: bc
          });
        }
      }
    };
    key_ctrl_l = function() {
      var ac, all, ar, bc, br, caret;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, br = caret.br, bc = caret.bc;
      ac = 0;
      if (all[ar - 1] != null) {
        ar -= 1;
        ac = void 0;
      }
      return write_text({
        all: all,
        ar: ar,
        ac: ac,
        br: br,
        bc: bc
      });
    };
    key_ctrl_k = function() {
      var ac, all, ar, caret;
      caret = wrap_text();
      if (caret.same) {
        all = caret.all, ar = caret.ar, ac = caret.ac;
        all[ar] = all[ar].slice(0, ac);
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      }
    };
    key_ctrl_u = function() {
      var ac, all, ar, caret;
      caret = wrap_text();
      if (caret.same) {
        all = caret.all, ar = caret.ar, ac = caret.ac;
        all[ar] = all[ar].slice(ac);
        ac = 0;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      }
    };
    key_esc = function() {
      return area.blur();
    };
    key_ctrl_shift_k = function() {
      var ac, all, ar, br, caret;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, br = caret.br;
      if (caret.same) {
        all = all.slice(0, ar).concat(all.slice(ar + 1));
        ac = 0;
        if (ar !== 0) {
          ar -= 1;
          ac = void 0;
        }
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      } else {
        all = all.slice(0, ar).concat(all.slice(br + 1));
        ar = ar > 0 ? ar - 1 : 0;
        return write_text({
          all: all,
          ar: ar
        });
      }
    };
    key_ctrl_shift_d = function() {
      var ac, all, ar, bc, br, caret, duplicate;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
      if (caret.same) {
        all = all.slice(0, +ar + 1 || 9e9).concat(all.slice(ar));
        ar += 1;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      } else {
        all = all.slice(0, +br + 1 || 9e9).concat(all.slice(ar));
        duplicate = br - ar + 1;
        ar += duplicate;
        br += duplicate;
        return write_text({
          all: all,
          ar: ar,
          ac: ac,
          br: br,
          bc: bc
        });
      }
    };
    key_enter = function() {
      var ac, all, ar, caret, line, spaces;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, ac = caret.ac;
      if (caret.same) {
        all = all.slice(0, +ar + 1 || 9e9).concat(all.slice(ar));
        line = all[ar];
        all[ar] = all[ar].slice(0, ac);
        spaces = (all[ar].match(/^\s*/))[0];
        all[ar + 1] = spaces + line.slice(ac);
        o(all);
        ac = spaces.length;
        ar += 1;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      }
    };
    key_backspace = function() {
      var ac, all, ar, caret, n, pair;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, ac = caret.ac;
      if (caret.same) {
        if (all[ar].slice(0, ac).match(/^\s+$/)) {
          n = all[ar].slice(0, ac).length;
          if (even(n)) {
            all[ar] = all[ar].slice(0, n - 2) + all[ar].slice(n);
          } else {
            all[ar] = all[ar].slice(0, n - 1) + all[ar].slice(n);
          }
          ac = n - 2;
          return write_text({
            all: all,
            ar: ar,
            ac: ac
          });
        } else if ((all[ar - 1] != null) && caret.as) {
          if (all[ar - 1].match(/^\s+$/)) {
            all = all.slice(0, ar - 1).concat(all.slice(ar));
            ar = ar - 1;
            ac = 0;
            return write_text({
              all: all,
              ar: ar,
              ac: ac
            });
          }
        } else if (all[ar].length > 1 && (!caret.ae)) {
          pair = all[ar].slice(ac - 1, +ac + 1 || 9e9);
          if (pair === '{}' || pair === '()' || pair === '[]' || pair === '""' || pair === "''" || pair === '``') {
            all[ar] = all[ar].slice(0, ac - 1) + all[ar].slice(ac + 1);
            ac -= 1;
            return write_text({
              all: all,
              ar: ar,
              ac: ac
            });
          }
        }
      }
    };
    key_ctrl_enter = function() {
      var all, ar, caret, new_line;
      caret = wrap_text();
      all = caret.all, ar = caret.ar;
      if (caret.same) {
        new_line = (all[ar].match(/^\s*/))[0];
        all = all.slice(0, +ar + 1 || 9e9).concat([new_line]).concat(all.slice(ar + 1));
        ar += 1;
        return write_text({
          all: all,
          ar: ar
        });
      }
    };
    key_ctrl_shift_enter = function() {
      var all, ar, caret, new_line;
      caret = wrap_text();
      all = caret.all, ar = caret.ar;
      if (caret.same) {
        new_line = (all[ar].match(/^\s*/))[0];
        all = all.slice(0, ar).concat([new_line]).concat(all.slice(ar));
        return write_text({
          all: all,
          ar: ar
        });
      }
    };
    key_ctrl_shift_up = function() {
      var ac, all, ar, bc, br, caret, index, line, t_line, _i, _len, _ref, _ref1;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
      if (caret.same) {
        if (ar > 0) {
          _ref = [all[ar - 1], all[ar]], all[ar] = _ref[0], all[ar - 1] = _ref[1];
          ar -= 1;
          return write_text({
            all: all,
            ar: ar,
            ac: ac
          });
        }
      } else {
        if (ar > 0) {
          t_line = all[ar - 1];
          _ref1 = all.slice(ar, +br + 1 || 9e9);
          for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
            line = _ref1[index];
            all[ar + index - 1] = line;
          }
          all[br] = t_line;
          ar -= 1;
          br -= 1;
          return write_text({
            all: all,
            ar: ar,
            ac: ac,
            br: br,
            bc: bc
          });
        }
      }
    };
    key_ctrl_shift_down = function() {
      var ac, all, ar, bc, br, caret, index, line, t_line, _i, _len, _ref, _ref1;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, ac = caret.ac, bc = caret.bc, br = caret.br;
      if (caret.same) {
        if (ar < all.length - 1) {
          _ref = [all[ar + 1], all[ar]], all[ar] = _ref[0], all[ar + 1] = _ref[1];
          ar += 1;
          return write_text({
            all: all,
            ar: ar,
            ac: ac
          });
        }
      } else {
        if (br < all.length - 1) {
          t_line = all[br + 1];
          _ref1 = all.slice(ar, +br + 1 || 9e9);
          for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
            line = _ref1[index];
            all[ar + index + 1] = line;
          }
          all[ar] = t_line;
          ar += 1;
          br += 1;
          return write_text({
            all: all,
            ar: ar,
            ac: ac,
            br: br,
            bc: bc
          });
        }
      }
    };
    key_bracket = function(bracket) {
      var ac, all, ar, bc, br, caret;
      caret = wrap_text();
      all = caret.all, ac = caret.ac, ar = caret.ar, br = caret.br, bc = caret.bc;
      all[br] = all[br].slice(0, bc) + bracket[1] + all[br].slice(bc);
      all[ar] = all[ar].slice(0, ac) + bracket[0] + all[ar].slice(ac);
      ac += 1;
      bc += 1;
      return write_text({
        all: all,
        ar: ar,
        ac: ac,
        br: br,
        bc: bc
      });
    };
    key_bracket_close = function(closer) {
      var ac, all, ar, caret, target;
      caret = wrap_text();
      all = caret.all, ar = caret.ar, ac = caret.ac;
      if (caret.same) {
        target = all[ar][ac];
        if ((target != null) && target === closer) {
          ac += 1;
          return write_text({
            all: all,
            ar: ar,
            ac: ac
          });
        }
      }
    };
    key_home = function() {
      var ac, all, ar, caret, spaces;
      caret = wrap_text();
      if (caret.same) {
        all = caret.all, ar = caret.ar, ac = caret.ac;
        spaces = all[ar].match(/^\s+/);
        ac = spaces != null ? spaces[0].length : 0;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      }
    };
    key_quote = function(sign) {
      var ac, all, ar, bc, br, caret, line;
      caret = wrap_text();
      if (caret.same) {
        all = caret.all, ar = caret.ar, ac = caret.ac;
        line = all[ar];
        if (line[ac] !== sign) {
          all[ar] = line.slice(0, ac) + sign + sign + line.slice(ac);
        }
        ac += 1;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      } else {
        all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
        line = all[ar];
        all[ar] = line.slice(0, ac) + sign + line.slice(ac);
        ac += 1;
        if (ar === br) {
          bc += 1;
        }
        line = all[br];
        all[br] = line.slice(0, bc) + sign + line.slice(bc);
        return write_text({
          all: all,
          ar: ar,
          ac: ac,
          br: br,
          bc: bc
        });
      }
    };
    call_shortcut = {
      9: key_tab,
      13: key_enter,
      8: key_backspace,
      36: key_home,
      219: function() {
        return key_bracket('[]');
      },
      192: function() {
        return key_quote('`');
      },
      221: function() {
        return key_bracket_close(']');
      },
      'shift 9': key_shift_tab,
      'shift 57': function() {
        return key_bracket('()');
      },
      'shift 48': function() {
        return key_bracket_close(')');
      },
      'shift 219': function() {
        return key_bracket('{}');
      },
      'shift 221': function() {
        return key_bracket_close('}');
      },
      'shift 222': function() {
        return key_quote('"');
      },
      'ctrl 76': key_ctrl_l,
      'ctrl 13': key_ctrl_enter,
      'ctrl 75': key_ctrl_k,
      'ctrl 85': key_ctrl_u,
      'ctrl shift 13': key_ctrl_shift_enter,
      'ctrl shift 75': key_ctrl_shift_k,
      'ctrl shift 68': key_ctrl_shift_d,
      'ctrl shift 38': key_ctrl_shift_up,
      'ctrl shift 40': key_ctrl_shift_down
    };
    return area.onkeydown = function(e) {
      var mark;
      mark = '';
      if (e.altKey) {
        mark += 'alt ';
      }
      if (e.ctrlKey) {
        mark += 'ctrl ';
      }
      if (e.shiftKey) {
        mark += 'shift ';
      }
      mark += String(e.keyCode);
      o(mark);
      if (call_shortcut[mark] != null) {
        return call_shortcut[mark](area);
      }
    };
  };
});
